λ> scala-cli test project.scala scala/Part1Introduction/
scala/Part1Introduction/.Code1WhatAreStreams.sc.~undo-tree~
scala/Part1Introduction/.Code2IncrementalPipelines.sc.~undo-tr
ee~
scala/Part1Introduction/.Code2Operators.sc.~undo-tree~
scala/Part1Introduction/.Code3IncrementalPipelines.sc.~undo-tr
ee~
scala/Part1Introduction/.Code3ReasoningAboutStreamProcessing.s
c.~undo-tree~
scala/Part1Introduction/.Code4CombiningOperators.sc.~undo-tree
~
scala/Part1Introduction/.Code5FanOutAndIn.sc.~undo-tree~
scala/Part1Introduction/.Ex1WhatAreStreams.solutions.test.scal
a.~undo-tree~
scala/Part1Introduction/.Ex1WhatAreStreams.test.scala.~undo-tr
ee~
scala/Part1Introduction/.Ex2IncrementalPipelines.solutions.tes
t.scala.~undo-tree~
scala/Part1Introduction/.Ex2IncrementalPipelines.test.scala.~u
ndo-tree~
scala/Part1Introduction/.Ex3Combining.solutions.test.scala.~un
do-tree~
scala/Part1Introduction/.Ex4FanOutAndIn.solutions.test.scala.~
undo-tree~
scala/Part1Introduction/.Ex4FanOutAndIn.test.scala.~undo-tree~
scala/Part1Introduction/.Fig1Evaluation.scala.~undo-tree~
scala/Part1Introduction/.Fig2Take.scala.~undo-tree~
scala/Part1Introduction/.Fig3CombiningZip.scala.~undo-tree~
scala/Part1Introduction/.Fig3FlatMap.scala.~undo-tree~
scala/Part1Introduction/.scala-build
scala/Part1Introduction/Code1WhatAreStreams.sc
scala/Part1Introduction/Code2IncrementalPipelines.sc
scala/Part1Introduction/Code3ReasoningAboutStreamProcessing.sc
scala/Part1Introduction/Code3ReasoningAboutStreamProcessing.sc
~
scala/Part1Introduction/Code4CombiningOperators.sc
scala/Part1Introduction/Code5FanOutAndIn.sc
scala/Part1Introduction/Ex1WhatAreStreams.solutions.test.scala
scala/Part1Introduction/Ex1WhatAreStreams.solutions.test.scala
~
scala/Part1Introduction/Ex1WhatAreStreams.test.scala
scala/Part1Introduction/Ex2IncrementalPipelines.solutions.test
.scala
scala/Part1Introduction/Ex2IncrementalPipelines.solutions.test
.scala~
scala/Part1Introduction/Ex2IncrementalPipelines.test.scala
scala/Part1Introduction/Ex3Combining.solutions.test.scala
scala/Part1Introduction/Ex3Combining.solutions.test.scala~
λ> scala-cli test project.scala scala/Part1Introduction/Ex1Wha
tAreStreams.solutions.test.scala
Compiling project (Scala 3.7.0, JVM (21))
Compiled project (Scala 3.7.0, JVM (21))
Compiling project (test, Scala 3.7.0, JVM (21))
Compiled project (test, Scala 3.7.0, JVM (21))
Ex1WhatAreStreamsSolutions:
  + get the first two numbers 0.064s
  + get the seventh to the ninth number 0.005s
  + get the first three odd numbers 0.004s
  + get the 1000th number 0.032s
  + get the sum of the first 10 numbers 0.004s
λ> scala-cli test project.scala scala/Part1Introduction/Ex1Wha
tAreStreams.solutions.test.scala
Compiling project (test, Scala 3.7.0, JVM (21))
Compiled project (test, Scala 3.7.0, JVM (21))
0
1
Ex1WhatAreStreamsSolutions:
  + get the first two numbers 0.075s
λ> scala-cli test project.scala scala/Part1Introduction/Ex1Wha
tAreStreams.solutions.test.scala
Compiling project (test, Scala 3.7.0, JVM (21))
Compiled project (test, Scala 3.7.0, JVM (21))
The number is 0
The number is 1
Ex1WhatAreStreamsSolutions:
  + get the first two numbers 0.071s
λ> scala-cli test project.scala scala/Part1Introduction/Ex1Wha
tAreStreams.solutions.test.scala
Compiling project (test, Scala 3.7.0, JVM (21))
Compiled project (test, Scala 3.7.0, JVM (21))
The number is 0
The number is 1
Ex1WhatAreStreamsSolutions:
  + get the first two numbers 0.067s
  + get odd numbers less than six 0.006s
λ>
λ> scala-cli test project.scala scala/Part1Introduction/Ex1Wha
tAreStreams.solutions.test.scala
Compiling project (test, Scala 3.7.0, JVM (21))
Compiled project (test, Scala 3.7.0, JVM (21))
Ex1WhatAreStreamsSolutions:
  + get odd numbers less than six 0.064s
λ> scala-cli test project.scala scala/Part1Introduction/Ex1Wha
tAreStreams.solutions.test.scala
Compiling project (test, Scala 3.7.0, JVM (21))
Compiled project (test, Scala 3.7.0, JVM (21))
^Cλscala-cli repl project.scala
Compiling project (Scala 3.7.0, JVM (21))
Compiled project (Scala 3.7.0, JVM (21))
Welcome to Scala 3.7.0 (21.0.4, Java OpenJDK 64-Bit Server VM)
.
Type in expressions for evaluation. Or try :help.

scala> import fs2.*

scala> def mostCommonInStream(ids: Stream[Pure, Long]): Long =
 {
     |   val initialCounts: Map[String, Long] = Map.empty
     |   val finalCounts = ids
     |     .fold(initialCounts) { (counts, id) =>
     |       val previousCount = counts.getOrElse(id, 0)
     |       counts + ((id, previousCount + 1))
     |     }
     |     .compile
     |     .last
     |     .getOrElse(initialCounts)
     |   val (mostCommonId, _) = finalCounts.maxBy { case (_,
count) => count }
     |   mostCommonId
     | }
     |
     |

-- [E007] Type Mismatch Error: -------------------------------
------------------
5 |      val previousCount = counts.getOrElse(id, 0)
  |                                           ^^
  |                                           Found:    (id :
Long)
  |                                           Required: String
  |
  | longer explanation available when compiling with `-explain
`
-- [E007] Type Mismatch Error: -------------------------------
------------------
6 |      counts + ((id, previousCount + 1))
  |                 ^^
  |                 Found:    (id : Long)
  |                 Required: String
  |
  | longer explanation available when compiling with `-explain
`
-- [E007] Type Mismatch Error: -------------------------------
------------------
12 |  mostCommonId
   |  ^^^^^^^^^^^^
   |  Found:    (mostCommonId : String)
   |  Required: Long
   |
   | longer explanation available when compiling with `-explai
n`
3 errors found

scala>

scala> def mostCommonInStream(ids: Stream[Pure, String]): Stri
ng = {
     |   val initialCounts: Map[String, Int] = Map.empty
     |   val finalCounts = ids
     |     .fold(initialCounts) { (counts, id) =>
     |       val previousCount = counts.getOrElse(id, 0)
     |       counts + ((id, previousCount + 1))
     |     }
     |     .compile
     |     .last
     |     .getOrElse(initialCounts)
     |   val (mostCommonId, _) = finalCounts.maxBy { case (_,
count) => count }
     |   mostCommonId
     | }
     |
     |
def mostCommonInStream(ids: fs2.Stream[fs2.Pure, String]): Str
ing

scala> val userIds: Stream[Pure, String] =
     |   Stream.range(0, Int.MaxValue).map(i => s"u$i")
     |
val userIds: fs2.Stream[fs2.Pure, String] = Stream(..)

scala> mostCommonInStream(userIds)
^C
λ> scala-cli repl project.scala
Welcome to Scala 3.7.0 (21.0.4, Java OpenJDK 64-Bit Server VM)
.
Type in expressions for evaluation. Or try :help.

scala> import fs2.*

scala> def mostCommonInStream(ids: Stream[Pure, String]): Stri
ng = {
     |   val initialCounts: Map[String, Int] = Map.empty
     |   val finalCounts = ids
     |     .fold(initialCounts) { (counts, id) =>
     |       val previousCount = counts.getOrElse(id, 0)
     |       counts + ((id, previousCount + 1))
     |     }
     |     .compile
     |     .last
     |     .getOrElse(initialCounts)
     |   val (mostCommonId, _) = finalCounts.maxBy { case (_,
count) => count }
     |   mostCommonId
     | }
     |
     |
def mostCommonInStream(ids: fs2.Stream[fs2.Pure, String]): Str
ing

scala> def mostCommonInStream(ids: Stream[Pure, String]): Stri
ng = {
     |   val initialCounts: Map[String, Int] = Map.empty
     |   val finalCounts = ids
     |     .fold(initialCounts) { (counts, id) =>
     |       val previousCount = counts.getOrElse(id, 0)
     |       counts + ((id, previousCount + 1))
     |     }
     |     .compile
     |     .last
     |     .getOrElse(initialCounts)
     |   val (mostCommonId, _) = finalCounts.maxBy { case (_,
count) => count }
     |   mostCommonId
     | }
     |
     |
def mostCommonInStream(ids: fs2.Stream[fs2.Pure, String]): Str
ing

scala> def mostCommonInStream(ids: Stream[Pure, String]): Stri
ng = {
     |   val initialCounts: Map[String, Int] = Map.empty
     |   val finalCounts = ids
     |     .fold(initialCounts) { (counts, id) =>
     |       val previousCount = counts.getOrElse(id, 0)
     |       counts + ((id, previousCount + 1))
     |     }
     |     .compile
     |     .last
     |     .getOrElse(initialCounts)
     |   val (mostCommonId, _) = finalCounts.maxBy { case (_,
count) => count }
     |   mostCommonId
     | }
     |
     |
def mostCommonInStream(ids: fs2.Stream[fs2.Pure, String]): Str
ing

scala> val userIds: Stream[Pure, String] =
     |   Stream.range(0, Int.MaxValue).map(i => s"u$i")
     |
val userIds: fs2.Stream[fs2.Pure, String] = Stream(..)

scala> mostCommonInStream(userIds)
java.lang.OutOfMemoryError: Java heap space
  at fs2.Pull$Succeeded.map(Pull.scala:660)
  at fs2.Pull$Succeeded.map(Pull.scala:658)
  at fs2.Pull$$anon$4.cont(Pull.scala:263)
  at fs2.Pull$BindBind.cont(Pull.scala:734)
  at fs2.Pull$ContP.apply(Pull.scala:682)
  at fs2.Pull$ContP.apply$(Pull.scala:681)
  at fs2.Pull$Bind.apply(Pull.scala:690)
  at fs2.Pull$Bind.apply(Pull.scala:690)
  at fs2.Pull$UnconsRunR$1.out$$anonfun$2(Pull.scala:1019)
  at fs2.Pull$UnconsRunR$1$$Lambda/0x00000001276dd258.apply(Un
known Source)
  at fs2.Pull$.interruptGuard$1$$anonfun$1(Pull.scala:952)
  at fs2.Pull$$$Lambda/0x00000001276c9410.apply(Unknown Source
)
  at cats.effect.SyncIO.flatMapK$1(SyncIO.scala:368)
  at cats.effect.SyncIO.succeeded$1(SyncIO.scala:309)
  at cats.effect.SyncIO.runLoop$1(SyncIO.scala:238)
  at cats.effect.SyncIO.unsafeRunSync(SyncIO.scala:383)
  at fs2.Compiler$$anon$5.apply(Compiler.scala:136)
  at fs2.Stream$CompileOps.foldChunks(Stream.scala:5226)
  at fs2.Stream$CompileOps.last(Stream.scala:5267)
  at rs$line$4$.mostCommonInStream(rs$line$4:8)
  ... 12 elided


scala>   def mostCommon(k: Int, ids: Stream[Pure, String]): St
ring = {
     |     // Replace this implementation with the Misra Gries
 summary.
     |     val initialCounts: Map[String, Int] = Map.empty
     |     val finalCounts = ids
     |       .fold(initialCounts) { (counts, id) =>
     |         counts.get(id) match {
     |           case Some(previousCount)       => counts + ((
id, previousCount + 1))
     |           case None if (counts.size < k) => counts + ((
id, 1))
     |           case None =>
     |             counts.collect {
     |               case (id, count) if count > 1 => (id, cou
nt - 1)
     |             }
     |         }
     |       }
     |       .compile
     |       .last
     |       .getOrElse(initialCounts)
     |     val (mostCommonId, _) = finalCounts.maxBy { case (_
, count) => count }
     |     mostCommonId
     |   }
     |
     |
def mostCommon(k: Int, ids: fs2.Stream[fs2.Pure, String]): Str
ing

scala>   val userIds: Stream[Pure, String] =
     |     Stream
     |       .range(0, Int.MaxValue)
     |       .map(id => s"u$id")
     |
val userIds: fs2.Stream[fs2.Pure, String] = Stream(..)

scala> userIds.take(10).toLis
t

-- [E008] Not Found Error: -----------------------------------
------------------
1 |userIds.take(10).toLis
  |^^^^^^^^^^^^^^^^^^^^^^
  |value toLis is not a member of fs2.Stream[fs2.Pure, String]
1 error found

scala> t

-- [E006] Not Found Error: -----------------------------------
------------------
1 |t
  |^
  |Not found: t
  |
  | longer explanation available when compiling with `-explain
`
1 error found

scala>

scala> userIds.take(10).toList
val res1: List[String] = List(u0, u1, u2, u3, u4, u5, u6, u7,
u8, u9)

scala> mostCommon(userIds)
-- [E007] Type Mismatch Error: -------------------------------
------------------
1 |mostCommon(userIds)
  |           ^^^^^^^
  |           Found:    (userIds : fs2.Stream[fs2.Pure, String
])
  |           Required: Int
  |
  | longer explanation available when compiling with `-explain
`
1 error found

scala> mostCommon(100, userIds)
^C
λ> scala-cli repl project.scala Welcome to Scala 3.7.0 (21.0.4
, Java OpenJDK 64-Bit Server VM).
Type in expressions for evaluation. Or try :help.


scala> import fs2.*

scala>   def mostCommon(k: Int, ids: Stream[Pure, String]): St
ring = {
     |     // Replace this implementation with the Misra Gries
 summary.
     |     val initialCounts: Map[String, Int] = Map.empty
     |     val finalCounts = ids
     |       .fold(initialCounts) { (counts, id) =>
     |         counts.get(id) match {
     |           case Some(previousCount)       => counts + ((
id, previousCount + 1))
     |           case None if (counts.size < k) => counts + ((
id, 1))
     |           case None =>
     |             counts.collect {
     |               case (id, count) if count > 1 => (id, cou
nt - 1)
     |             }
     |         }
     |       }
     |       .compile
     |       .last
     |       .getOrElse(initialCounts)
     |     val (mostCommonId, _) = finalCounts.maxBy { case (_
, count) => count }
     |     mostCommonId
     |   }
     |
     |
def mostCommon(k: Int, ids: fs2.Stream[fs2.Pure, String]): Str
ing

scala>   val userIds: Stream[Pure, String] =
     |     Stream
     |       .range(0, Int.MaxValue)
     |       .map(id => s"u$id")
     |
val userIds: fs2.Stream[fs2.Pure, String] = Stream(..)

scala> mostCommon(userIds)
-- [E007] Type Mismatch Error: -------------------------------
------------------
1 |mostCommon(userIds)
  |           ^^^^^^^
  |           Found:    (userIds : fs2.Stream[fs2.Pure, String
])
  |           Required: Int
  |
  | longer explanation available when compiling with `-explain
`
1 error found

scala> mostCommon(100, userIds)